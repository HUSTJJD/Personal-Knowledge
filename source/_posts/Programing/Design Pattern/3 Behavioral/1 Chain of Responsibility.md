---
title: 1 Chain of Responsibility
abbrlink: 60646
categories:
  - Programing
  - Design Pattern
  - 3 Behavioral
date: 2025-01-04 15:15:34
tags:
---


##  意图

**责任链模式**是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

##  解决方案

与许多其他行为设计模式一样， **责任链**会将特定行为转换为被称作_处理者_的独立对象。 在上述示例中， 每个检查步骤都可被抽取为仅有单个方法的类， 并执行检查操作。 请求及其数据则会被作为参数传递给该方法。

模式建议你将这些处理者连成一条链。 链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。 除了处理请求外， 处理者还负责沿着链传递请求。 请求会在链上移动， 直至所有处理者都有机会对其进行处理。

最重要的是： 处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。

所有处理者类均实现同一接口是关键所在。 每个具体处理者仅关心下一个包含 `execute`执行方法的处理者。 这样一来， 你就可以在运行时使用不同的处理者来创建链， 而无需将相关代码与处理者的具体类进行耦合。

##  责任链模式适合应用场景

 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。

 该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。

 当必须按顺序执行多个处理者时， 可以使用该模式。

 无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。

 如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。

 如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。

## 实现方式

1. 声明处理者接口并描述请求处理方法的签名。
    确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。
2. 为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。
    该类需要有一个成员变量来存储指向链上下个处理者的引用。 你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变， 则需要定义一个设定方法来修改引用成员变量的值。
    为了使用方便， 你还可以实现处理方法的默认行为。 如果还有剩余对象， 该方法会将请求传递给下个对象。 具体处理者还能够通过调用父对象的方法来使用这一行为。
3. 依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：
    - 是否自行处理这个请求。
    - 是否将该请求沿着链进行传递。
4. 客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。
5. 客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。
6. 由于链的动态性， 客户端需要准备好处理以下情况：
    - 链中可能只有单个链接。
    - 部分请求可能无法到达链尾。
    - 其他请求可能直到链尾都未被处理。

##  责任链模式优缺点

-  你可以控制请求处理的顺序。
-  _单一职责原则_。 你可对发起操作和执行操作的类进行解耦。
-  _开闭原则_。 你可以在不更改现有代码的情况下在程序中新增处理者。
-  部分请求可能未被处理。
